import * as ts from 'typescript';
import * as config from './config';
import * as Symbol from './symbol';
export default class TypeScriptParser {
    private fileNames;
    private config;
    private program;
    private typeChecker;
    private emptyType;
    private moduleCache;
    private typeCache;
    private symbols;
    private mappedTypes;
    private arrayTypeName;
    private typeReferenceStack;
    private readonly currentTypeReference;
    constructor(fileNames: string[], config: config.Config);
    readonly sourceFiles: ts.SourceFile[];
    readonly types: Symbol.Type[];
    readonly modules: Symbol.Module[];
    parse(): void;
    validate(): void;
    private tryGetSymbolAtLocation(node);
    private getSymbolAtLocation(node);
    private getSymbolLinksOfMappedType(symbol);
    private tryGetMappedTypeNode(type);
    private tryGetTemplateType(type);
    private checkFlags(flagsA, flagsB);
    private checkModifiers(modifiers, kind);
    private makeErrorWithTypeInfo(message, type);
    private makeErrorWithSymbolInfo(message, symbol);
    private parseType(type);
    private createTyphenSymbol<T>(symbol, typhenSymbolClass, assumedNameSuffix?);
    private createTyphenType<T>(type, typhenTypeClass, assumedNameSuffix?);
    private getOrCreateTyphenModule(symbol);
    private getDeclarationInfos(symbol);
    private getDecorators(symbol);
    private getParentModule(symbol);
    private getDocComment(symbol);
    private getAssumedName(symbol, typeName);
    private isTyphenPrimitiveType(type);
    private isArrayType(type);
    private getSymbolsInScope(node, symbolFlags);
    private parseDecorator(decorator);
    private parseSourceFile(sourceFile);
    private parseModule(symbol);
    private parseEnum(type);
    private parseIndexInfos(type);
    private parseGenericType<T>(type, typhenTypeClass);
    private parseObjectType(type);
    private parseIndexType(type);
    private parseIndexedAccessType(type);
    private parseArray(type);
    private parseFunction(type);
    private parsePrimitiveType(type);
    private parsePrimitiveType(type);
    private parseUnknownType(type);
    private parseTypeParameter(type);
    private parseTuple(type);
    private parseUnionType(type);
    private parseIntersectionType(type);
    private parseStringLiteralType(type);
    private parseBooleanLiteralType(type);
    private parseNumberLiteralType(type);
    private parseEnumLiteralType(type);
    private parseProperty(symbol, isOwn?, isOptional?, isReadonly?);
    private parseMethod(symbol, isOwn?, isOptional?, baseTypes?);
    private parseSignature(signature, suffixName?, baseTypes?);
    private parseTypePredicate(node, parameters);
    private getUnboundTypeParameters(type);
    private rebindTypeParameters(type, typeName, typeArgument);
    private parseParameter(symbol, baseTypes?);
    private showFunction(fnc);
    private parseVariable(symbol);
    private parseTypeAlias(symbol);
    private mAnySourceFileMatches;
    private readonly anySourceFileMatches;
    private shouldRebindTypeParameters(type);
}
